# Эти Квантификаторы не позволяют задать кол. желаемых вхождений
'''
+ позволяет искать соответствие с 1 или более вхождением
* позволяет искать соответствие с 0 или более вхождением
? позволяет искать соответствие с 0 или 1 вхождением
'''

# Кол. желаемых вхождений можно задавать с помощью {}
'''
{3} - ровно 3 вхождения
{2,4} - от 2х до 4х вхождений

{5,} - не менее 5  вхождений
{,3} - не более 3х вхождений
'''

# Жадность и ленивость квантификаторов
'''
По умолчанию все квантификаторы являются жадными. Т.е. они ищут наибольшее возможное вхождение
Т.е. квантификаторы:
*
+
?
{m,n}
{,n}
{m,}
Будут выдавать максимально возможное вхождение
'''

"""
import re
text = "Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Белоруссии</B>. Приносим свои извинения."
regex = r'<B>.*</B>'
res = re.findall(regex, text)

print(res)
"""

# Любой квантификатор можно сделать ленивым добавив ?
"""
import re
text = "Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Белоруссии</B>. Приносим свои извинения."
regex = r'<B>.*?</B>'
res = re.findall(regex, text)

print(res)
"""


# () - позволяют искать какую-то определённую группу
# Или создавать вложенные подвыражения
'''
Пример регулярного выражения для поиска почтовых адресов США.
regex = r'\d{5}(-\d{4})*'
'''


# Ссылки назад - \номер группы
'''
import re

text = "Это текст, в котором котором несколько слов    слов повторяются, хотя они и не   не должны повторяться повторяться."
regex = r'(\w+)[ ]+\1' # (\w) - подвыражение, к которому можно обратиться позже используя его номер - \1
res = re.findall(regex, text)
print(res) # Почему И попало? Ведь оно не повторяется 2 раза?
'''

# Пример с анализом верных тегов HTML
'''
import re

text = """
<BODY>
<H1>Добро пожаловать на курсы BEEGEEK</H1>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.
Следующие курсы:
<H2>ООП</H2>
<h2>Алгоритмы и структуры данных</h3>
Оставайтесь с нами!
</BODY>
"""

regex = r'<[Hh]([1-6])>.*</[Hh]\1>'
res = re.sub(regex, '', text)
print(res) # Вырезка всех правильных HTML тегов заголовков
'''

# У ссылок назад по номерам есть недостаток - при редактировании/удалении групп - ломается весь RegEx
# Чтобы этого избежать - группам можно давать имена, по которым на них же и ссылаться!
'''
'''

import re

text = """
<BODY>
<H1>Добро пожаловать на курсы BEEGEEK</H1>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.
Следующие курсы:
<H2>ООП</H2>
<h2>Алгоритмы и структуры данных</h3>
Оставайтесь с нами!
</BODY>
"""

# regex = r'<[Hh]?P<name>([1-6])>.*</[Hh]\g<name>>'
# res = re.sub(regex, '', text)

# print(res)

